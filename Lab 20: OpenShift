Objectives:
  - Create standard K8s resources

# Before interacting with a cluster, login
oc login <clusterURL>

# To create a pod from an image, OpenShift requires a pod resource definition (via JSON or YAML file, or oc new-app command, or web console)

# There is no easy way for a pod to discover the IP addresses of other pods (a service layer provides this abstraction when, let's say, a pod restarts with a different internal IP address)
# The same service exists for all nodes in a cluster

# targetPort has to match containerPort from a pod container definition
# port attributed is the one exposed by the service (clients connect to the service port and the service forwards packets to targetPort)

# An application typically finds a service IP and port by using env
# Service host is the service IP, service port is the service TCP
# Another way is to use the OpenShift internal DNS service (only visible to pods, SVC_NAME . PROJECT_NAME.svc.cluster.local)

# A pod has to created after a service is created to be discovered using env, otherwise it can only be discovered via DNS queries

# OpenShift proxies connections to a service via the public IP of the compute node host and nodePort IP (which is exposed to external clients by binding to ports on the compute node host, which then proxies to the service IP); oc edit svc
# Preferred method is to use OpenShift Routes; oc expose command to expose service for external access

# oc port-forward is good for single port and more secure than NodePort for exposing service to direct connections
# Good for testing things out
# Forwards port 3306 from a dev machine to port 3306 on the db pod where a MySQL server accepts network connections from inside a container
# Not public or a route, just a secret tunnel for your personal workstation
[user@host ~]$ oc port-forward mysql-openshift-1-glqrp 3306:3306

# Create an app based on a mysql image from Docker Hub with the label set to db=mysql
[user@host ~]$ oc new-app mysql MYSQL_USER=user MYSQL_PASSWORD=pass MYSQL_DATABASE=testdb -l db=mysql

# Create an app based on Docker image from private registry
oc new-app --docker-image=myregistry.com/mycompany/app --name=myapp

# Create an app based on Git repo source code
oc new-app https://github.com/openshift/ruby-hello-world --name=ruby-hello

# Create an app based on an existing template
oc new-app \
> --template=mysql-persistent \
> -p MYSQL_USER=user1 -p MYSQL_PASSWORD=mypa55 -p MYSQL_DATABASE=testdb \
> -p MYSQL_ROOT_PASSWORD=r00tpa55 -p VOLUME_CAPACITY=10Gi

# oc process --parameters mysql-persistent -n openshift gets a list of all parameters that the template is using

# List PersistentVolume objects in a cluster (make sure data is not lost when pod is deleted)
[admin@host ~]$ oc get pv
# NAME     CAPACITY  ACCESS MODES  RECLAIM POLICY   STATUS      CLAIM   ...
# pv0001   1Mi       RWO           Retain           Available           ...
# pv0002   10Mi      RWX           Recycle          Available           ...

# See YAML definition for a PersistentVolume (use -o yaml)
oc get pv pv0001 -o yaml

# To add more PersistentVolume objects to a cluster from a file (pv1001.yaml must be a resource definition file)
oc create -f pv1001.yaml

# To request a dedicated storage resource from the cluster pool, create a pvc yaml file, which defines capacity and throughput
# Then create it
oc create -f pvc.yaml

# After a PVC is created, OpenShift attempts to bind a Persistent volume object to the PersistentVolumeClaim object
# To list PVCs in a project and show whether a persistent volume is bound to the PVC
oc get pvc

# To use a persistent volume in a pod, define a volume mount (pvol) for a container that references the PVC object in the resource definition file

# When working with resources in the same project, try to group them by application, environment, or other criteria via labels
# app and template keys are common for labels
# To retrieve resources by label
oc get svc,deployments -l app=nexus

# Labels from a template will apply to every resource generated by the template

# To obtain a list of all the resources available in a RHOCP cluster and their abbreviations, use the oc api-resources or kubectl api-resources commands.

# oc get all to retrieve everything from current project/namespace

# Always give the type and the name when using oc
# Resource type, resource name

# If more than one container in a pod
oc exec {pod_name} -c {container_name}

oc get RESOURCE_TYPE RESOURCE_NAME
oc describe RESOURCE_TYPE RESOURCE_NAME
oc create (usually paired with oc get RESOURCE_TYPE RESOURCE_NAME -o yaml)
oc edit
oc delete RESOURCE_TYPE name
oc exec CONTAINER_ID options

oc get svc, deployment -l app=nexus


